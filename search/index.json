[{"content":"This morning, an EternalBlue-vulnerable machine used for testing for Stanford\u0026rsquo;s Hack Lab course accidentally given a public IP address on Google Cloud was unsurprisingly pwned and used to launch further EternalBlue scanning against other public web hosts.\nThis blog post describes our course\u0026rsquo;s infrastructure setup (including why we had that testing box in the first place), how we discovered and remediated the incident, and how we used the incident as a way to teach students about incident response and public disclosure.\nHack Lab\u0026rsquo;s Google Cloud infrastructure Hack Lab is Stanford\u0026rsquo;s introduction to cybersecurity, cyberlaw, and cyber policy class, with nearly 180 students enrolled. This fall, I\u0026rsquo;m one of five TAs for the class, and I had the responsibility of building much of our course infrastructure on Google Cloud (GCP)\u0026rsquo;s Compute Engine before the quarter started.\nWhy GCP? We need to provide students with tools for learning about cyber topics during lab sections such as Burp Suite, Wireshark, nmap, and others. Previously, we used to give each student a Kali Linux virtual machine (VM) download preprovisioned with these tools. However, as more and more students use M1 Macs that don\u0026rsquo;t support standard x86-64 virtualization, this solution started to become difficult to maintain.\nThis year, we decided to move those Kali VMs to the cloud to simplify our setup. Students can either use remote desktop or SSH to access the machines and use the security tools we\u0026rsquo;ve set up for them. Each machine has a public IP address attached, as well as a hostname via GCP\u0026rsquo;s DNS support set up for easier access.\nSetting up an EternalBlue lab This week\u0026rsquo;s lab concerns buffer overflows and corporate intrusion, where students learn to use Metasploit to break into an EternalBlue-vulnerable Windows host. Each student gets their own vulnerable Windows Server 2008 virtual machine on a private subnet, which they learn how to gain administrator access on and find flags on the system that they use to pass the lab.\nSetting up this lab was nontrivial, as our first worry was GCP\u0026rsquo;s tendency to automatically patch Windows and Linux hosts running vulnerable software. We thought this would be an issue for the lab. As it turns out, however, autopatching only happens when the machines are accessible to the public internet and have GCP\u0026rsquo;s VM manager agent installed, neither of which applied to our machines.\nThe real issue, in fact, was configuring our own GCP networks and firewalls to allow the necessary network accesses for EternalBlue break-ins. This required creating the Windows subnet on the right GCP region and zone, locking down the Windows machines to only have private IPs, and opening the right ports on the Windows machines to expose SMB and on the Kali machines to enable the use of reverse shell listeners.\nFiguring these cloud nuances out took us much of the night of Sunday, October 9 into Monday, October 10, as well as much of Monday itself. Eventually we were able to get everything to work and published the lab on 1:30am Tuesday morning, before students had to start working on them at 8:30am. Luckily, students didn\u0026rsquo;t seem to have major issues completing the lab that day.\nHack Lab gets hacked Notification of a possible pwn This morning, I woke up to three emails from GCP sent between the hours of 4:00am and 6:00am that notified us that our course infrastructure was used to conduct port scans against nearly 230,000 IP addresses for EternalBlue vulnerability.\nIn my sleep-addled state when I got up, my first thought was \u0026ldquo;this doesn\u0026rsquo;t look super legit to me, as when Google wants to tell you that your security sucks, usually it\u0026rsquo;s a robot sending an email and not a human.\u0026rdquo; But then I was able to verify the identity of the sender and the legitimacy of the email \u0026ndash; at which point I thought \u0026ldquo;we\u0026rsquo;re running a hacking class where we\u0026rsquo;re telling students to EternalBlue their way into machines, of course there\u0026rsquo;s gonna be suspicious-looking traffic on the network.\u0026rdquo;\nAt that point I read the sentence that warned us about a machine being used to scan nearly 230,000 IP addresses between 12:40am and 2:50am, and it finally dawned on me that this couldn\u0026rsquo;t possibly be a student and that something was up here.\nA hurried incident response By now, it was nearly 9am and students would start using the machines again during the first lab section of the day at 10:30am. I called our head TA Cooper de Nicola so we could figure out what was going on, accidentally waking him after a few nights of less-than-satisfactory sleep (sorry Cooper :/).\nWe quickly determined that the IP address we were emailed about was a test machine we created at 4:24am on Monday morning with the name win-final-template-1-attackme1. In our sleep-addled state that day, we had accidentally given an EternalBlue-vulnerable machine a public IP address, exposing it to the web and the dangers (i.e., automated scanners) that lurk in the wild.\nOur first course of action was to immediately shut down and destroy that VM instance, as well as a few other similar test machines that had similar issues. Given our time constraints, we decided we wouldn\u0026rsquo;t be able to do a thorough investigation of what the attacker was trying to do with our pwned box.\nOur best theory is that we were simply targeted by an automated web scanner that detected our EternalBlue vulnerability, broke into the machine, and then started using that machine to repeatedly scan web hosts on the public internet for EternalBlue vulnerabilties (given the targeting of port 445 in particular). However, it\u0026rsquo;s entirely possible that the attacker also installed malware or a cryptominer on the machine.\nIt\u0026rsquo;s extremely rare that attackers can break out of a GCP virtual machine to gain access to the broader GCP project, so we felt relatively safe that the project itself hadn\u0026rsquo;t been maliciously accessed. However, we couldn\u0026rsquo;t rule out the possibility that the student Windows or Kali machines had been broken into as well, so we decided to simply burn those VM instances down and rebuild it from scratch.\nThanks to the robust and maintainable infrastructure management code we built out before the quarter started, we were able to do this in only 15 minutes while only using 7 command-line commands and have everything ready well before the lab started at 10:30am. The only remaining issue was that some students received scary messages warning of an SSH man-in-the-middle attack as the VM fingerprint had changed on regeneration. We had to provide instructions so that students weren\u0026rsquo;t encumbered by this in the course of completing the lab.\nTurning the hack into a teachable moment Conveniently, this week at Hack Lab is when we teach about corporate intrusion, security research, and responsible disclosure in lecture. We decided we could use our own incident as a way of doing a public postmortem to our students and illustrating how to responsibly handle incidents like these. So Cooper and I got up on the stage of Dinkelspiel Auditorium and ate the humble pie.\nIn particular, we talked about how the breach happened, the (nonexistent) impact on students and their data, and how enterprises have an ethical obligation to inform their stakeholders about breaches once incidents are remediated. We feel that leading by example in this context is highly important given the less-than-stellar reputation of Stanford student startups with regards to properly handling vulnerability disclosures and other security incidents.\nConclusion This incident yields a couple of lessons for ourselves in the future here: always audit what infrastructure we have exposed to the public, and be extra careful running deliberately vulnerable services! In general, this hack demonstrates that breaches can happen to anyone, including the instructors of a cybersecurity class. As such, how one responds to a breach is as or more important than keeping things secure in the first place, and I\u0026rsquo;m pretty proud of our response here.\n","date":"2022-10-12","permalink":"https://saligrama.io/blog/post/hack-lab-got-hacked/","tags":[],"title":"Flipping the script: when a hacking class gets hacked"},{"content":"This is a continuation of my previous post about upgrading personal security. This post focuses on preventing evil maid attacks using disk encryption and secure boot.\nWith this post, I compiled and summarized all of the resources I used to do all of this configuration. The hope is that having a set of steps in one place reduces the need to go hunting across different Reddit posts, blog posts, and wiki articles as I did.\nRecap: physical threat model An evil maid attack is a situation where an attacker has physical access to a device. For now, the way I think about this scenario is that an attacker can have physical access to one of the following:\nPhone Laptop YubiKey Even with any one of these devices in their possession, the adversary should never be able to access any of our data or accounts. Additionally, we should not be locked out of our own accounts even with one device missing.\nDisclaimer: Full physical security is impossible to achieve on standard consumer laptops. This is a best effort using commonly available tools and methods, and will not protect against a determined (e.g. nation-state) adversary.\nRecap: hardware To recap, I\u0026rsquo;ll be using the following hardware for this post:\nLaptop: Lenovo ThinkPad X1 Carbon Gen 9 Runs a dual-boot setup with Arch Linux and Windows 11 Initially, both the Linux and Windows partitions were unencrypted Hardware security key: YubiKey 5C NFC Stage three: Linux disk encryption with FIDO2/YubiKey authentication These instructions will demonstrate how to encrypt the Linux partition in-place. If you were smarter than me when you initially set up the laptop and encrypted the disk, skip to the next step.\nNow it\u0026rsquo;s time to encrypt Linux data at rest using LUKS2. We start with the following disk setup:\n~ » lsblk NAME MAJ:MIN RM SIZE RO TYPE MOUNTPOINTS nvme0n1 259:0 0 476.9G 0 disk ├─nvme0n1p1 259:1 0 260M 0 part /boot # EFI ESP, systemd-boot ├─nvme0n1p2 259:2 0 16M 0 part # Windows reserved ├─nvme0n1p3 259:3 0 153.4G 0 part # Windows C: ├─nvme0n1p4 259:4 0 322.3G 0 part / # Arch Linux root, ext4 └─nvme0n1p5 259:5 0 1000M 0 part # Windows reserved Observe that the Linux root is currently unencrypted and not part of an LVM setup. I wanted to do the encryption without having to wipe the partition, set up LUKS2 on LVM, and then restore the data; I just wanted to encrypt-in-place. The Arch Linux wiki has documentation on how to do so, but hopefully my instructions below are a bit clearer.\nDisclaimer: For these steps to work, your /boot partition must be separate from your root partition. /boot must be unencrypted so the bootloader can load a kernel and initramfs that are capable of decrypting your root partition.\nDisclaimer: These steps are specific to a system that uses the systemd-boot bootloader. If you use GRUB or rEFInd, your configuration will likely look different.\nDisclaimer: I AM NOT RESPONSIBLE FOR ANY DATA LOSS YOU MIGHT ENCOUNTER FOLLOWING THESE INSTRUCTIONS.\nWith that out of the way, boot into an Arch Linux live USB and run the following commands.\n# 1. Check the file system for errors e2fsck -f /dev/nvme0n1p4 # 2. Reduce filesystem size by 32M # to make space for the LUKS header resize2fs -p /dev/nvme0n1p4 $(expr `fdisk -l | grep nvme0n1p4 | awk '{print $4}'` - 32768)s # 3. Encrypt the partition, reducing partition size by 32M. # Give it a secure password when requested. cryptsetup reencrypt --encrypt --reduce-device-size 32M /dev/nvme0n1p4 # 4. Open the encrypted partition with your password and mount it. cryptsetup open /dev/nvme0n1p4 root mount /dev/mapper/root /mnt mount /dev/nvme0n1p1 /mnt/boot Now we need to do some config editing.\nChroot into your system: arch-chroot /mnt\nEdit /etc/mkinitcpio.conf, add the following to the HOOKS section:\nsystemd keyboard sd-vconsole sd-encrypt Regenerate your initramfs: mkinitcpio -P linux\nFind the UUID of your root partition (not the encrypted volume within):\nblkid | grep nvme0n1p4 | awk '{print $2}' You want the value inside the quotes (i.e. UUID=\u0026quot;YOUR_UUID\u0026quot;).\nEdit your systemd-boot bootloader entry for Arch Linux (mine was in /boot/loader/entries/arch.conf).\nFind your kernel command-line parameters (the line starting with options) If you have a section in your kernel-line options for your root partition (e.g. root=/dev/nvme0n1p4 or root=UUID=SOME_UUID), remove it. Directly after options, add rd.luks.name=YOUR_UUID=root root=/dev/mapper/root Exit the chroot: exit\nReboot: reboot; then pull out the live USB.\nIf everything has gone correcty, you should be all set. Now, select the Arch Linux boot entry at the systemd-boot menu and you should be prompted to enter your LUKS passphrase during the boot process.\nOur disk configuration should now display as follows.\n~ » lsblk NAME MAJ:MIN RM SIZE RO TYPE MOUNTPOINTS nvme0n1 259:0 0 476.9G 0 disk ├─nvme0n1p1 259:1 0 260M 0 part /boot ├─nvme0n1p2 259:2 0 16M 0 part ├─nvme0n1p3 259:3 0 153.4G 0 part ├─nvme0n1p4 259:4 0 322.3G 0 part | └─root 254:0 0 322.3G 0 crypt / └─nvme0n1p5 259:5 0 1000M 0 part Disk decryption with FIDO2/YubiKey Since systemd version 248 (March 2021), it has been possible to enroll a YubiKey as a way to do LUKS decryption at boot. Doing so only takes a few steps on your running system (no need for a live USB here).\nEnroll the key: systemd-cryptenroll --fido2-device=auto /dev/nvme0n1p4 Edit /etc/crypttab.initramfs (may be nonexistent or empty) and add the following line: # \u0026lt;name\u0026gt; \u0026lt;device\u0026gt; \u0026lt;password\u0026gt; \u0026lt;options\u0026gt; root\t/dev/nvme0n1p4\t-\tfido2-device=auto Edit your bootloader entry for Arch Linux (i.e. /boot/loader/entries/arch.conf). Before the root=/dev/mapper/root entry in the options line, add rd.luks.options=fido2-device=auto Reboot, and you should be all set. Stage four: evil maid hardening Unfortunately, disk encryption is not enough to defend against an evil maid attack, even when the attacker only has at most a few minutes with your device. Up until now, the code running before you decrypt your disk during boot is both unencrypted (sitting on an unencrypted /boot partition) and unverified.\nThis means that an attacker can replace your kernel (i.e. /boot/vmlinuz-linux) and/or initramfs (i.e., /boot/initramfs-linux.img) with a backdoored one, which can, for example, steal your LUKS decryption passphrase with a keylogger. To remedy this, we enable UEFI Secure Boot in order to make sure all the code running at boot is trusted.\nSecure boot verifies that all code running at boot is cryptographically signed using a private key whose public key is embedded in the computer\u0026rsquo;s NVRAM. Secure Boot is not a panacea, but it at least allows us to move the chain of trust from the unencrypted boot partition to the laptop firmware. Your laptop firmware is also not great, but chances are there\u0026rsquo;s no way around that short of buying a new laptop. When you buy a laptop running Windows, the key embedded in the NVRAM is Microsoft\u0026rsquo;s key. However, it is possible to enroll your own key in the NVRAM as well. The way most mainstream Linux distributions deal with secure boot is to load Shim, a UEFI bootloader that is signed by Microsoft, that then loads the actual Linux bootloader (usually GRUB or rEFInd). Shim then verifies the GRUB EFI loader and the loaded kernel. However, Shim does not verify the initramfs \u0026ndash; in practice, this is difficult to do because the initramfs is highly machine-dependent and also changes with every kernel update. This means that a standard Shim-based secure boot setup still does not protect you from an evil maid attack, since the initramfs can still be backdoored. Instead, our setup will involve embedding our own public key for verification into the laptop\u0026rsquo;s NVRAM, whose private key will sign our kernel, initramfs, and associated resources. The only code that is allowed to boot on our machine is code signed by either our private key or Microsoft\u0026rsquo;s private key.\nWhy do we need to keep Microsoft\u0026rsquo;s key, considering we could just sign the Windows bootloader ourselves? Unfortunately, my laptop, a Lenovo ThinkPad X1 Carbon Gen 9, has Option ROM firmware for a hardware device, which means that the Microsoft key is required to even initialize the device in the first place. There are plans to support initializing these devices without the Microsoft key in Linux secure boot managers such as sbctl. However, the current implementation is experimental. Actually implementing a fully trusted boot chain on Linux is tricky, and there have been reports that doing this improperly can brick your laptop.\nAs such, treat the following instructions as specific to my laptop (a Lenovo ThinkPad X1 Carbon Gen 9). These instructions follow from a Reddit comment I made on the subject in early May.\nDisclaimer: I AM NOT RESPONSIBLE FOR ANY DATA OR EQUIPMENT LOSS YOU MIGHT ENCOUNTER FOLLOWING THESE INSTRUCTIONS.\nPreparation: booting from a unified kernel image A Unified Kernel Image is a compilation containing the following:\nUEFI bootloader executable Linux kernel initramfs Kernel command-line arguments An optional splash screen Setting one up and configuring your system to boot from it is not particularly difficult. Morten Linderud/Foxboron, an Arch Linux maintainer, has a great guide on the subject. To summarize:\nEdit /etc/mkinitcpio.d/linux.preset Add the following lines: ALL_microcode=(/boot/*-ucode.img) default_efi_image=\u0026quot;/boot/EFI/Linux/linux.efi\u0026quot; default_options=\u0026quot;--splash /usr/share/systemd/bootctl/splash-arch.bmp\u0026quot; fallback_efi_image=\u0026quot;/boot/EFI/Linux/fallback.efi\u0026quot; Edit the line starting with fallback_options to contain fallback_options=\u0026quot;-S autodetect --splash /usr/share/systemd/bootctl/splash-arch.bmp\u0026quot; cat /proc/cmdline \u0026gt; /etc/kernel/cmdline Remove any references to initrd/initramfs. mkinitcpio -P linux Reboot and make sure that you have two new entries in your systemd-boot menu: one for Arch Linux, and one for Arch Linux fallback You can now safely remove /boot/loader/entries/arch.conf. Enrolling your key into secure boot Doing this used to be an extremely painful process, but luckily the sbctl tool makes this significantly easier.\nThese instructions were what worked on my system, and many steps were previously scattered across numerous blog posts, wiki pages, and Reddit comments. Part of my motivation for writing this post was to centralize these steps, at least for my newer ThinkPad, since the system will brick if this is done improperly.\nReboot into your UEFI interface and enable secure boot. Set the secure boot mode setting to \u0026ldquo;Setup mode,\u0026rdquo; which allows enrolling new keys. Then boot back into Arch. # Execute the following instructions as root # 2. Install sbctl pacman -S sbctl # 3. Create a keypair # The private key in this keypair is used to sign all # EFI code loaded at boot, which means that without the # signature, you will not be able to boot into Linux. # MAKE SURE YOU DO NOT LOSE THE PRIVATE KEY. sbctl create-keys # 4. Enroll your keys while keeping Microsoft's keys. # Experimentally, Option ROM devices can be supported # using `sbctl enroll-keys --tpm-eventlog`, but I have # not tested this and IT COULD LEAD TO EQUIPMENT LOSS. sbctl enroll-keys --microsoft # 5. Sign each of the EFI files that may appear somewhere # in the boot chain. The following files are specific # to my configuration, double check that you sign everything # you need to for your setup. sbctl sign -s /boot/EFI/Linux/linux.efi sbctl sign -s /boot/EFI/Linux/fallback.efi sbctl sign -s /boot/EFI/systemd/systemd-bootx64.efi sbctl sign -s /boot/EFI/Boot/bootx64.efi sbctl sign -s /boot/EFI/Microsoft/bootmgfw.efi sbctl sign -s /boot/EFI/Microsoft/bootmgr.efi sbctl sign -s /boot/EFI/Microsoft/memtest.efi # 6. Verify that all the files you need are signed sbctl list-files # 7. Verify that the sbctl pacman hook works on a kernel upgrade. # Ensure that the string \u0026quot;Signing EFI binaries...\u0026quot; appears. pacman -S linux Reboot into the UEFI interface and ensure that Secure Boot is still enabled. Verify that the Secure Boot mode setting has changed to \u0026ldquo;User mode.\u0026rdquo;\nTest booting into Arch, Arch fallback, and Windows. All should succeed without issues.\nSecuring the Windows partition with BitLocker At this point we can go ahead and simply enable BitLocker in Windows settings. Why did we need to wait this long?\nThe modern BitLocker implementation uses the hardware trusted platform module (TPM) to store the disk decryption key. Windows requires everything in the boot chain to be signed before it can retrieve the key from the TPM. This requires secure boot to be enabled. Without secure boot, we would be prompted for a long, randomly generated recovery password every single time we wanted to start Windows. Setting a UEFI password We\u0026rsquo;re not quite done yet: with access to the UEFI interface, an attacker could simply turn secure boot off, completely nullifying all the work we just did.\nNearly every UEFI implementation allows setting a password, so go ahead and do so. Make sure the password protects both the firmware interface itself and the boot device selector.\nWhy do we need to protect the boot list? We want to prevent an attack where the adversary can boot an Ubuntu or Fedora LiveUSB (whose loaders are Shim, trusted with Microsoft\u0026rsquo;s key), and then plant Shim, a signed kernel, and a backdoored initramfs on the unencrypted boot partition. Protecting the boot list both prevents an adversary from booting a LiveUSB and from being able to boot Shim once the attack is carried out. Finishing up: disabling Windows recovery Lastly, in Windows, we want to disable the recovery environment, which allows manipulating boot priority or booting to a USB.\nThis is pretty simple. Open Command Prompt as administrator and run reagentc /disable. Closing At this point, you should be reasonably protected from Evil Maid attacks. An adversary would probably need to carefully manipulate the boot priority list in the NVRAM in order to have any chance at mounting an attack. This requires a flash programmer and lots of time.\nOf course, this still leaves you susceptible to an $5 wrench attack. But this isn\u0026rsquo;t in the threat model, and if you\u0026rsquo;ve reached this point, you probably have bigger problems than your data.\nAcknowledgement: Thanks to Cody Ho for suggestions and edits.\n","date":"2022-05-04","permalink":"https://saligrama.io/blog/post/upgrading-personal-security-evil-maid/","tags":[],"title":"Upgrading my personal security, part two: disk encryption and secure boot"},{"content":"I\u0026rsquo;m someone who\u0026rsquo;s been reasonably technical for a long time, but was not really interested in security until about a year and a half ago. This means I had a lot of configuration set up for convenience, but without much in the way of security.\nIn the last few weeks, I started to change that and significantly upgraded my personal security. This post covers the first steps I took towards that end, starting with password generation and better two-factor authentication.\nThreat model Before delving into the details, we should take a moment to lay out a threat model \u0026ndash; the types of attacks that an attacker is permitted to perform and that our setup should be able to reasonably defend against.\nThis is important because an adversary with significant resources (e.g. a nation-state actor) will always win. If you have such a determined attacker trying to break into your system, then you probably have bigger problems than reading this blog post.\nRemote threat model This is the situation where an attacker doesn\u0026rsquo;t have physical access to your system. Such an attacker\u0026rsquo;s capabilities include:\nBrowser-based malware Phishing/social engineering Password cracking Open-source intelligence (OSINT) SIM-swapping Shoulder-surfing Personal information dumps from poorly secured services An attacker, even with these tools, should not be able to get into our accounts. If an account or password has been compromised, our data and accounts on other services should still be protected.\nPhysical threat model This is the situation where an attacker has physical access to a device (i.e. an evil maid attack). For now, the way I think about this scenario is that an attacker can have physical access to one of the following:\nPhone Laptop YubiKey Even with any one of these devices in their possession, the adversary should never be able to access any of our data or accounts. Additionally, we should not be locked out of our own accounts even with one device missing.\nAddressing the remote threat model will be the subject of this post, whereas the physical threat model will be addressed in part two.\nBaseline setup Hardware For this post, I\u0026rsquo;ll be using the following hardware:\nLaptop: Lenovo ThinkPad X1 Carbon Gen 9 Phone: Apple iPhone 13 Pro Max Hardware security key: YubiKey 5C NFC Security misconfigurations This is the fun part: detailing a number of missteps I\u0026rsquo;ve made with security in the name of convenience over the last several years.\nPassword generation. My previous password generation algorithm was something I came up when I was much younger and dumber This scheme was likely brute-forceable by a determined adversary, and in addition if my password on one insecure site got leaked, it would also compromise all of my other account passwords. Inconsistent use of two-factor authentication. It took me an embarassingly long time to add 2FA to my password manager, Bitwarden. Yet my Epic Games account had 2FA on \u0026ndash; and I\u0026rsquo;m not even that much of a gamer. Leaving my laptop hard drive unencrypted. Given physical access to an unencrypted laptop, an evil maid attack is extremely easy. A trivial example is to boot a live USB, mount the Linux root partition, and edit /etc/passwd and /etc/shadow to give yourself a backdoored user with root privileges. Fully preventing an evil maid attack is difficult on Linux, as will be detailed later in this post, but it\u0026rsquo;s not an excuse to have an unencrypted disk! Stage one: fixing bad passwords The interesting bit here is generating a random secure password that\u0026rsquo;s also reasonably fast to type (if not memorable). I use hsxkpasswd on my laptop, which generates a random XKCD-style password with additional digit and special-character padding. A convenience script to do the generation is as follows:\n~ » cat /usr/local/bin/genpwd #!/bin/bash hsxkpasswd -c ~/.hsxkpasswdrc 2\u0026gt;/dev/null | xclip -r -selection c This script generates a password using the JSON configuration file found at ~/.hsxkpasswdrc and immediately copies it into the clipboard for easy pasting. You can generate a configuration file with the format you want at xkpasswd.\nOn my phone, I use gjPwd, which is essentially a hsxkpasswd frontend for iOS.\nActually resetting the passwords is a simple, though tedious, game of whack-a-mole. Every time I logged into a service with a password generated using the old algorithm, I would immediately reset the password.\nI started with banks, and then moved onto other services that stored financial information. This led to my Twitter rant about airlines\u0026rsquo; poor digital security policies.\nStage two: consistently using 2FA At this point, there\u0026rsquo;s no excuse to not use 2FA when a site offers it. This is especially true for anything that has access to financial information such as banks or credit card issuers.\nWhy FIDO2/WebAuthn 2FA is the way to go My strong preference for 2FA is to use the YubiKey to do FIDO2/WebAuthn-based 2FA.\nWhy this instead of SMS-based or authenticator/TOTP app-based 2FA? SMS-based 2FA puts you at risk of your OTP code being stolen through a SIM-swapping attack. Using an authenticator app such as Authy is better, but still leaves you vulnerable to a phishing attack that requests your login information and your TOTP code, and then passes the details along to the actual service to log in as you. It is up to you to scrutinize the website you\u0026rsquo;ve navigated to and make sure it\u0026rsquo;s not fraudulent. Using a YubiKey will prevent both these attacks, because the key will simply refuse to authenticate if the domain doesn\u0026rsquo;t match the profile saved in the hardware. Unfortunately, the list of services supporting hardware security key-based authentication is mostly limited to big tech companies and security-focused products. For these services, adding a security key is fairly easy; you just follow the prompts in the service\u0026rsquo;s security settings.\nSecuring TOTP 2FA behind a YubiKey, plus some phishing protection For everything else, most services that support any 2FA do support TOTP-based authentication, and the YubiKey can store TOTP codes for use with such services. However, the TOTP code storage is limited to only 32 codes, even on the latest models such as my YubiKey 5C NFC (2020). As more and more services start to support 2FA, 32 TOTP codes will probably not cut it long-term.\nI currently pay for Bitwarden Premium, which now allows me to select FIDO2/WebAuthn using the YubiKey as my only means of 2FA. I now rely on Bitwarden to do TOTP 2FA (which is also a Premium feature), since I can store TOTP secrets for an unlimited amount of services. This also offers some protection against phishing attacks, since Bitwarden won\u0026rsquo;t bring up the TOTP entry for a website whose domain mismatches the saved one.\nFreshly adding Bitwarden TOTP is fairly easy for most services; you just go through the prompts to set up 2FA, click on \u0026ldquo;I can\u0026rsquo;t scan the QR code\u0026rdquo;, and then paste the TOTP secret into the Bitwarden browser extension.\nMigrating from Authy, my previous TOTP provider, is a different story, since Authy doesn\u0026rsquo;t allow you to export TOTP secrets for use with a different service. Instead, you need to remove the Authy 2FA option from each service and add a new 2FA option for Bitwarden. Some websites make this extra annoying and force you to disable 2FA altogether and re-enable it in order to switch TOTP providers.\nBad (and nonexistent) 2FA implementations Some services either only allow SMS-based 2FA, or force you to use SMS-based 2FA as a backup for TOTP or FIDO2/WebAuthn 2FA solutions. You\u0026rsquo;re only as secure as your weakest backup \u0026ndash; so even if SMS 2FA isn\u0026rsquo;t the primary 2FA method, as long as it exists as an option, you\u0026rsquo;re still vulnerable to a SIM-swap attack. A non-exhaustive name-and-shame list from my personal experience:\nYahoo Microsoft Uber Lyft Bank of America Barclays Credit Karma Seriously, why do the financial services \u0026ndash; those with arguably the most sensitive data at stake \u0026ndash; only allow the least secure form of 2FA?\nEven worse are services that store financial information, yet have no support for any form of 2FA. In my experience this has mostly been airline frequent flyer programs \u0026ndash; again, refer to my Twitter rant about all the security issues that airlines have.\nAs far as I know, Qantas, British Airways, and Singapore Airlines support 2FA. No US carriers do. Closing At this point, we\u0026rsquo;ve significantly decreased our attack surface for a remote adversary. Our passwords are now truly random for every service, and every service with sensitive information on it (save for airline frequent flyer accounts) has some form of 2FA on it. When TOTP 2FA is needed, it\u0026rsquo;s locked behind Bitwarden, which requires FIDO2/WebAuthn to log in.\nUnfortunately, this is not necessarily comforting when someone with physical access to your laptop can simply just reset your root password by booting from a USB stick, thereby gaining full compromise of your assets.\nPreventing these attacks is the focus of the next post.\n","date":"2022-05-04","permalink":"https://saligrama.io/blog/post/upgrading-personal-security-web/","tags":[],"title":"Upgrading my personal security, part one: password generation, 2FA, YubiKey"},{"content":"Hello, world! Test post for this blog.\nchar code[] = \u0026quot;\\xe9\\x1e\\x00\\x00\\x00\\xb8\u0026quot; \u0026quot;\\x04\\x00\\x00\\x00\\xbb\\x01\u0026quot; \u0026quot;\\x00\\x00\\x00\\x59\\xba\\x0f\u0026quot; \u0026quot;\\x00\\x00\\x00\\xcd\\x80\\xb8\u0026quot; \u0026quot;\\x01\\x00\\x00\\x00\\xbb\\x00\u0026quot; \u0026quot;\\x00\\x00\\x00\\xcd\\x80\\xe8\u0026quot; \u0026quot;\\xdd\\xff\\xff\\xff\\x48\\x65\u0026quot; \u0026quot;\\x6c\\x6c\\x6f\\x2c\\x20\\x57\u0026quot; \u0026quot;\\x6f\\x72\\x6c\\x64\\x21\\x0a\u0026quot;; int main(int argc, char **argv) { (*(void(*)())code)(); return 0; } ","date":"2022-05-02","permalink":"https://saligrama.io/blog/post/hello/","tags":[],"title":"Hello, world!"}]