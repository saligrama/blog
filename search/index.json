[{"content":"Motivation This is a continuation of my previous post about upgrading personal security. This post focuses on preventing evil maid attacks using disk encryption and secure boot.\nWith this post, I compiled and summarized all of the resources I used to do all of this configuration. The hope is that having a set of steps in one place reduces the need to go hunting across different Reddit posts, blog posts, and wiki articles as I did.\nRecap: physical threat model An evil maid attack is a situation where an attacker has physical access to a device. For now, the way I think about this scenario is that an attacker can have physical access to one of the following:\n Phone Laptop YubiKey  Even with any one of these devices in their possession, the adversary should never be able to access any of our data or accounts. Additionally, we should not be locked out of our own accounts even with one device missing.\nDisclaimer: Full physical security is impossible to achieve on standard consumer laptops. This is a best effort using commonly available tools and methods, and will not protect against a determined (e.g. nation-state) adversary.\nRecap: hardware The physical hardware I have salient to this post are:\n Laptop: Lenovo ThinkPad X1 Carbon Gen 9  Runs a dual-boot setup with Arch Linux and Windows 11 Initially, both the Linux and Windows partitions were unencrypted   Hardware security key: YubiKey 5C NFC  Stage three: Linux disk encryption with YubiKey authentication These instructions will demonstrate how to encrypt the Linux partition in-place. If you were smarter than me when you initially set up the laptop and encrypted the disk, skip to the next step.\nNow it\u0026rsquo;s time to encrypt Linux data at rest using LUKS2. We start with the following disk setup:\n~ » lsblk NAME MAJ:MIN RM SIZE RO TYPE MOUNTPOINTS nvme0n1 259:0 0 476.9G 0 disk ├─nvme0n1p1 259:1 0 260M 0 part /boot # EFI ESP, systemd-boot ├─nvme0n1p2 259:2 0 16M 0 part # Windows reserved ├─nvme0n1p3 259:3 0 153.4G 0 part # Windows C: ├─nvme0n1p4 259:4 0 322.3G 0 part / # Arch Linux root, ext4 └─nvme0n1p5 259:5 0 1000M 0 part # Windows reserved  Observe that the Linux root is currently unencrypted and not part of an LVM setup. I wanted to do the encryption without having to wipe the partition, set up LUKS2 on LVM, and then restore the data; I just wanted to encrypt-in-place. The Arch Linux wiki has documentation on how to do so, but hopefully my instructions below are a bit clearer.\nDisclaimer: For these steps to work, your /boot partition must be separate from your root partition. /boot must be unencrypted so the bootloader can load a kernel and initramfs that are capable of decrypting your root partition.\nDisclaimer: These steps are specific to a system that uses the systemd-boot bootloader. If you use GRUB or rEFInd, your configuration will likely look different.\nDisclaimer: I AM NOT RESPONSIBLE FOR ANY DATA LOSS YOU MIGHT ENCOUNTER FOLLOWING THESE INSTRUCTIONS.\nWith that out of the way, boot into an Arch Linux live USB and run the following commands.\n# 1. Check the file system for errors e2fsck -f /dev/nvme0n1p4 # 2. Reduce filesystem size by 32M # to make space for the LUKS header resize2fs -p /dev/nvme0n1p4 $(expr `fdisk -l | grep nvme0n1p4 | awk '{print $4}'` - 32768) # 3. Encrypt the partition, reducing partition size by 32M. # Give it a secure password when requested. cryptsetup reencrypt --encrypt --reduce-device-size 32M /dev/nvme0n1p4 # 4. Open the encrypted partition with your password and mount it. cryptsetup open /dev/nvme0n1p4 root mount /dev/mapper/root /mnt mount /dev/nvme0n1p1 /mnt/boot  Now we need to do some config editing.\n Chroot into your system: arch-chroot /mnt\n  Edit /etc/mkinitcpio.conf, add the following to the HOOKS section:\n systemd keyboard sd-vconsole sd-encrypt    Regenerate your initramfs: mkinitcpio -P linux\n  Find the UUID of your root partition (not the encrypted volume within):\nblkid | grep nvme0n1p4 | awk '{print $2}'  You want the value inside the quotes (i.e. UUID=\u0026quot;YOUR_UUID\u0026quot;).\n  Edit your systemd-boot bootloader entry for Arch Linux (mine was in /boot/loader/entries/arch.conf).\n Find your kernel command-line parameters (the line starting with options) If you have a section in your kernel-line options for your root partition (e.g. root=/dev/nvme0n1p4 or root=UUID=SOME_UUID), remove it. Directly after options, add rd.luks.name=YOUR_UUID=root root=/dev/mapper/root      Exit the chroot: exit\n  Reboot: reboot; then pull out the live USB.\n  If everything has gone correcty, you should be all set. Now, select the Arch Linux boot entry at the systemd-boot menu and you should be prompted to enter your LUKS passphrase during the boot process.\nOur disk configuration should now display as follows.\n~ » lsblk NAME MAJ:MIN RM SIZE RO TYPE MOUNTPOINTS nvme0n1 259:0 0 476.9G 0 disk ├─nvme0n1p1 259:1 0 260M 0 part /boot ├─nvme0n1p2 259:2 0 16M 0 part ├─nvme0n1p3 259:3 0 153.4G 0 part ├─nvme0n1p4 259:4 0 322.3G 0 part | └─root 254:0 0 322.3G 0 crypt / └─nvme0n1p5 259:5 0 1000M 0 part  Disk decryption with a YubiKey Since systemd version 248 (March 2021), it has been possible to enroll a YubiKey as a way to do LUKS decryption at boot. Doing so only takes a few steps on your running system (no need for a live USB here).\n Enroll the key: systemd-cryptenroll --fido2-device=auto /dev/nvme0n1p4   Edit /etc/crypttab.initramfs (may be nonexistent or empty) and add the following line: # \u0026lt;name\u0026gt; \u0026lt;device\u0026gt; \u0026lt;password\u0026gt; \u0026lt;options\u0026gt; root\t/dev/nvme0n1p4\t-\tfido2-device=auto   Edit your bootloader entry for Arch Linux (i.e. /boot/loader/entries/arch.conf). Before the root=/dev/mapper/root entry in the options line, add rd.luks.options=fido2-device=auto   Reboot, and you should be all set.  Stage four: evil maid hardening Unfortunately, disk encryption is not enough to defend against an evil maid attack, even when the attacker only has at most a few minutes with your device. Up until now, the code running before you decrypt your disk during boot is both unencrypted (sitting on an unencrypted /boot partition) and unverified.\n This means that an attacker can replace your kernel (i.e. /boot/vmlinuz-linux) and/or initramfs (i.e., /boot/initramfs-linux.img) with a backdoored one, which can, for example, steal your LUKS decryption passphrase with a keylogger.  To remedy this, we enable UEFI Secure Boot in order to make sure all the code running at boot is trusted.\n Secure boot verifies that all code running at boot is cryptographically signed using a private key whose public key is embedded in the computer\u0026rsquo;s NVRAM.  Secure Boot is not a panacea, but it at least allows us to move the chain of trust from the unencrypted boot partition to the laptop firmware. Your laptop firmware is also not great, but chances are there\u0026rsquo;s no way around that short of buying a new laptop.   When you buy a laptop running Windows, the key embedded in the NVRAM is Microsoft\u0026rsquo;s key. However, it is possible to enroll your own key in the NVRAM as well. The way most mainstream Linux distributions deal with secure boot is to load Shim, a UEFI bootloader that is signed by Microsoft, that then loads the actual Linux bootloader (usually GRUB or rEFInd). Shim then verifies the GRUB EFI loader and the loaded kernel.  However, Shim does not verify the initramfs \u0026ndash; in practice, this is difficult to do because the initramfs is highly machine-dependent and also changes with every kernel update. This means that a standard Shim-based secure boot setup still does not protect you from an evil maid attack, since the initramfs can still be backdoored.    Instead, our setup will involve embedding our own public key for verification into the laptop\u0026rsquo;s NVRAM, whose private key will sign our kernel, initramfs, and associated resources. The only code that is allowed to boot on our machine is code signed by either our private key or Microsoft\u0026rsquo;s private key.\n Why do we need to keep Microsoft\u0026rsquo;s key, considering we could just sign the Windows bootloader ourselves? Unfortunately, my laptop, a Lenovo ThinkPad X1 Carbon Gen 9, has Option ROM firmware for a hardware device, which means that the Microsoft key is required to even initialize the device in the first place. There are plans to support initializing these devices without the Microsoft key in Linux secure boot managers such as sbctl. However, the current implementation is experimental.  Actually implementing a fully trusted boot chain on Linux is tricky, and there have been reports that doing this improperly can brick your laptop.\nAs such, treat the following instructions as specific to my laptop (a Lenovo ThinkPad X1 Carbon Gen 9). These instructions follow from a Reddit comment I made on the subject in early May.\nDisclaimer: I AM NOT RESPONSIBLE FOR ANY DATA OR EQUIPMENT LOSS YOU MIGHT ENCOUNTER FOLLOWING THESE INSTRUCTIONS.\nPreparation: booting from a unified kernel image A Unified Kernel Image is a compilation containing the following:\n UEFI bootloader executable Linux kernel initramfs Kernel command-line arguments An optional splash screen  Setting one up and configuring your system to boot from it is not particularly difficult. Morten Linderud/Foxboron, an Arch Linux maintainer, has a great guide on the subject. To summarize:\n Edit /etc/mkinitcpio.d/linux.preset  Add ALL_microcode=(/boot/*-ucode.img) Add default_efi_image=\u0026quot;/boot/EFI/Linux/linux.efi\u0026quot; Add default_options=\u0026quot;--splash /usr/share/systemd/bootctl/splash-arch.bmp\u0026quot; Add fallback_efi_image=\u0026quot;/boot/EFI/Linux/fallback.efi\u0026quot; Edit the line starting with fallback_options to contain fallback_options=\u0026quot;-S autodetect --splash /usr/share/systemd/bootctl/splash-arch.bmp\u0026quot;     cat /proc/cmdline \u0026gt; /etc/kernel/cmdline  Remove any references to initrd/initramfs.   mkinitcpio -P linux Reboot and make sure that you have two new entries in your systemd-boot menu: one for Arch Linux, and one for Arch Linux fallback You can now safely remove /boot/loader/entries/arch.conf.  Enrolling your key into secure boot Doing this used to be an extremely painful process, but luckily the sbctl tool makes this significantly easier.\nThese instructions were what worked on my system, and many steps were previously scattered across numerous blog posts, wiki pages, and Reddit comments. Part of my motivation for writing this post was to centralize these steps, at least for my newer ThinkPad, since the system will brick if this is done improperly.\n Reboot into your UEFI interface and enable secure boot. Set the secure boot mode setting to \u0026ldquo;Setup mode,\u0026rdquo; which allows enrolling new keys. Then boot back into Arch.  # Execute the following instructions as root # 2. Install sbctl pacman -S sbctl # 3. Create a keypair # The private key in this keypair is used to sign all # EFI code loaded at boot, which means that without the # signature, you will not be able to boot into Linux. # MAKE SURE YOU DO NOT LOSE THE PRIVATE KEY. sbctl create-keys # 4. Enroll your keys while keeping Microsoft's keys. # Experimentally, Option ROM devices can be supported # using `sbctl enroll-keys --tpm-eventlog`, but I have # not tested this and IT COULD LEAD TO EQUIPMENT LOSS. sbctl enroll-keys --microsoft # 5. Sign each of the EFI files that may appear somewhere # in the boot chain. The following files are specific # to my configuration, double check that you sign everything # you need to for your setup. sbctl sign -s /boot/EFI/Linux/linux.efi sbctl sign -s /boot/EFI/Linux/fallback.efi sbctl sign -s /boot/EFI/systemd/systemd-bootx64.efi sbctl sign -s /boot/EFI/Boot/bootx64.efi sbctl sign -s /boot/EFI/Microsoft/bootmgfw.efi sbctl sign -s /boot/EFI/Microsoft/bootmgr.efi sbctl sign -s /boot/EFI/Microsoft/memtest.efi # 6. Verify that all the files you need are signed sbctl list-files # 7. Verify that the sbctl pacman hook works on a kernel upgrade. # Ensure that the string \u0026quot;Signing EFI binaries...\u0026quot; appears. pacman -S linux   Reboot into the UEFI interface and ensure that Secure Boot is still enabled. Verify that the Secure Boot mode setting has changed to \u0026ldquo;User mode.\u0026rdquo;\n  Test booting into Arch, Arch fallback, and Windows. All should succeed without issues.\n  Securing the Windows partition with BitLocker At this point we can go ahead and simply enable BitLocker in Windows settings. Why did we need to wait this long?\n The modern BitLocker implementation uses the hardware trusted platform module (TPM) to store the disk decryption key. Windows requires everything in the boot chain to be signed before it can retrieve the key from the TPM. This requires secure boot to be enabled. Without secure boot, we would be prompted for a long, randomly generated recovery password every single time we wanted to start Windows.  Setting a UEFI password We\u0026rsquo;re not quite done yet: with access to the UEFI interface, an attacker could simply turn secure boot off, completely nullifying all the work we just did.\nNearly every UEFI implementation allows setting a password, so go ahead and do so. Make sure the password protects both the firmware interface itself and the boot device selector.\n Why do we need to protect the boot list? We want to prevent an attack where the adversary can boot an Ubuntu or Fedora LiveUSB (whose loaders are Shim, trusted with Microsoft\u0026rsquo;s key), and then plant Shim, a signed kernel, and a backdoored initramfs on the unencrypted boot partition.  Protecting the boot list both prevents an adversary from booting a LiveUSB and from being able to boot Shim once the attack is carried out.    Finishing up: disabling Windows recovery Lastly, in Windows, we want to disable the recovery environment, which allows manipulating boot priority or booting to a USB.\n This is pretty simple. Open Command Prompt as administrator and run reagentc /disable.  Closing At this point, you should be reasonably protected from Evil Maid attacks. An adversary would probably need to carefully manipulate the boot priority list in the NVRAM in order to have any chance at mounting an attack. This requires a flash programmer and lots of time.\nOf course, this still leaves you susceptible to an $5 wrench attack. But this isn\u0026rsquo;t in the threat model, and if you\u0026rsquo;ve reached this point, you probably have bigger problems than your data.\nAcknowledgement: Thanks to Cody Ho for suggestions and edits.\n","date":"2022-05-04","permalink":"https://saligrama.io/blog/post/upgrading-personal-security-evil-maid/","tags":[],"title":"Upgrading my personal security, part two: disk encryption and secure boot"},{"content":"Motivation I\u0026rsquo;m someone who\u0026rsquo;s been reasonably technical for a long time, but was not really interested in security until about a year and a half ago. This means I had a lot of configuration set up for convenience, but without much in the way of security.\nIn the last few weeks, I started to change that and significantly upgraded my personal security. This post covers the first steps I took towards that end, starting with password generation and better two-factor authentication.\nThreat model Before delving into the details, we should take a moment to lay out a threat model \u0026ndash; the types of attacks that an attacker is permitted to perform and that our setup should be able to reasonably defend against.\nThis is important because an adversary with significant resources (e.g. a nation-state actor) will always win. If you have such a determined attacker trying to break into your system, then you probably have bigger problems than reading this blog post.\nRemote threat model This is the situation where an attacker doesn\u0026rsquo;t have physical access to your system. Such an attacker\u0026rsquo;s capabilities include:\n Browser-based malware Phishing/social engineering Password cracking Open-source intelligence (OSINT) SIM-swapping Shoulder-surfing Personal information dumps from poorly secured services  An attacker, even with these tools, should not be able to get into our accounts. If an account or password has been compromised, our data and accounts on other services should still be protected.\nPhysical threat model This is the situation where an attacker has physical access to a device (i.e. an evil maid attack). For now, the way I think about this scenario is that an attacker can have physical access to one of the following:\n Phone Laptop YubiKey  Even with any one of these devices in their possession, the adversary should never be able to access any of our data or accounts. Additionally, we should not be locked out of our own accounts even with one device missing.\nAddressing the remote threat model will be the subject of this post, whereas the physical threat model will be addressed in part two.\nBaseline setup Hardware The physical hardware I have salient to this post are:\n Laptop: Lenovo ThinkPad X1 Carbon Gen 9 Phone: Apple iPhone 13 Pro Max Hardware security key: YubiKey 5C NFC  Security misconfigurations This is the fun part: detailing a number of missteps I\u0026rsquo;ve made with security in the name of convenience over the last several years.\n Password generation.  My previous password generation algorithm was something I came up when I was much younger and dumber This scheme was likely brute-forceable by a determined adversary, and in addition if my password on one insecure site got leaked, it would also compromise all of my other account passwords.   Inconsistent use of two-factor authentication.  It took me an embarassingly long time to add 2FA to my password manager, Bitwarden. Yet my Epic Games account had 2FA on \u0026ndash; and I\u0026rsquo;m not even that much of a gamer.   Leaving my laptop hard drive unencrypted.  Given physical access to an unencrypted laptop, an evil maid attack is extremely easy. A trivial example is to boot a live USB, mount the Linux root partition, and edit /etc/passwd and /etc/shadow to give yourself a backdoored user with root privileges. Fully preventing an evil maid attack is difficult on Linux, as will be detailed later in this post, but it\u0026rsquo;s not an excuse to have an unencrypted disk!    Stage one: fixing bad passwords The interesting bit here is generating a random secure password that\u0026rsquo;s also reasonably fast to type (if not memorable). I use hsxkpasswd on my laptop, which generates a random XKCD-style password with additional digit and special-character padding. A convenience script to do the generation is as follows:\n~ » cat /usr/local/bin/genpwd #!/bin/bash hsxkpasswd -c ~/.hsxkpasswdrc 2\u0026gt;/dev/null | xclip -r -selection c  This script generates a password using the JSON configuration file found at ~/.hsxkpasswdrc and immediately copies it into the clipboard for easy pasting. You can generate a configuration file with the format you want at xkpasswd.\nOn my phone, I use gjPwd, which is essentially a hsxkpasswd frontend for iOS.\nActually resetting the passwords is a simple, though tedious, game of whack-a-mole. Every time I logged into a service with a password generated using the old algorithm, I would immediately reset the password.\nI started with banks, and then moved onto other services that stored financial information. This led to my Twitter rant about airlines\u0026rsquo; poor digital security policies.\nStage two: consistently using 2FA At this point, there\u0026rsquo;s no excuse to not use 2FA when a site offers it. This is especially true for anything that has access to financial information such as banks or credit card issuers.\nWhy FIDO2/WebAuthn 2FA is the way to go My strong preference for 2FA is to use the YubiKey to do FIDO2/WebAuthn-based 2FA.\n Why this instead of SMS-based or authenticator/TOTP app-based 2FA? SMS-based 2FA puts you at risk of your OTP code being stolen through a SIM-swapping attack. Using an authenticator app such as Authy is better, but still leaves you vulnerable to a phishing attack that requests your login information and your TOTP code, and then passes the details along to the actual service to log in as you. It is up to you to scrutinize the website you\u0026rsquo;ve navigated to and make sure it\u0026rsquo;s not fraudulent. Using a YubiKey will prevent both these attacks, because the key will simply refuse to authenticate if the domain doesn\u0026rsquo;t match the profile saved in the hardware.  Unfortunately, the list of services supporting hardware security key-based authentication is mostly limited to big tech companies and security-focused products. For these services, adding a security key is fairly easy; you just follow the prompts in the service\u0026rsquo;s security settings.\nSecuring TOTP 2FA behind a YubiKey, plus some phishing protection For everything else, most services that support any 2FA do support TOTP-based authentication, and the YubiKey can store TOTP codes for use with such services. However, the TOTP code storage is limited to only 32 codes, even on the latest models such as my YubiKey 5C NFC (2020). As more and more services start to support 2FA, 32 TOTP codes will probably not cut it long-term.\nI currently pay for Bitwarden Premium, which now allows me to select FIDO2/WebAuthn using the YubiKey as my only means of 2FA. I now rely on Bitwarden to do TOTP 2FA (which is also a Premium feature), since I can store TOTP secrets for an unlimited amount of services. This also offers some protection against phishing attacks, since Bitwarden won\u0026rsquo;t bring up the TOTP entry for a website whose domain mismatches the saved one.\nFreshly adding Bitwarden TOTP is fairly easy for most services; you just go through the prompts to set up 2FA, click on \u0026ldquo;I can\u0026rsquo;t scan the QR code\u0026rdquo;, and then paste the TOTP secret into the Bitwarden browser extension.\nMigrating from Authy, my previous TOTP provider, is a different story, since Authy doesn\u0026rsquo;t allow you to export TOTP secrets for use with a different service. Instead, you need to remove the Authy 2FA option from each service and add a new 2FA option for Bitwarden. Some websites make this extra annoying and force you to disable 2FA altogether and re-enable it in order to switch TOTP providers.\nBad (and nonexistent) 2FA implementations Some services either only allow SMS-based 2FA, or force you to use SMS-based 2FA as a backup for TOTP or FIDO2/WebAuthn 2FA solutions. You\u0026rsquo;re only as secure as your weakest backup \u0026ndash; so even if SMS 2FA isn\u0026rsquo;t the primary 2FA method, as long as it exists as an option, you\u0026rsquo;re still vulnerable to a SIM-swap attack. A non-exhaustive name-and-shame list from my personal experience:\n Yahoo Microsoft Uber Lyft Bank of America Barclays Credit Karma  Seriously, why do the financial services \u0026ndash; those with arguably the most sensitive data at stake \u0026ndash; only allow the least secure form of 2FA?\nEven worse are services that store financial information, yet have no support for any form of 2FA. In my experience this has mostly been airline frequent flyer programs \u0026ndash; again, refer to my Twitter rant about all the security issues that airlines have.\n As far as I know, Qantas, British Airways, and Singapore Airlines support 2FA. No US carriers do.  Closing At this point, we\u0026rsquo;ve significantly decreased our attack surface for a remote adversary. Our passwords are now truly random for every service, and every service with sensitive information on it (save for airline frequent flyer accounts) has some form of 2FA on it. When TOTP 2FA is needed, it\u0026rsquo;s locked behind Bitwarden, which requires FIDO2/WebAuthn to log in.\nUnfortunately, this is not necessarily comforting when someone with physical access to your laptop can simply just reset your root password by booting from a USB stick, thereby gaining full compromise of your assets.\nPreventing these attacks is the focus of the next post.\n","date":"2022-05-04","permalink":"https://saligrama.io/blog/post/upgrading-personal-security-web/","tags":[],"title":"Upgrading my personal security, part one: password generation, 2FA, YubiKey"},{"content":"Hello, world! Test post for this blog.\nchar code[] = \u0026quot;\\xe9\\x1e\\x00\\x00\\x00\\xb8\u0026quot; \u0026quot;\\x04\\x00\\x00\\x00\\xbb\\x01\u0026quot; \u0026quot;\\x00\\x00\\x00\\x59\\xba\\x0f\u0026quot; \u0026quot;\\x00\\x00\\x00\\xcd\\x80\\xb8\u0026quot; \u0026quot;\\x01\\x00\\x00\\x00\\xbb\\x00\u0026quot; \u0026quot;\\x00\\x00\\x00\\xcd\\x80\\xe8\u0026quot; \u0026quot;\\xdd\\xff\\xff\\xff\\x48\\x65\u0026quot; \u0026quot;\\x6c\\x6c\\x6f\\x2c\\x20\\x57\u0026quot; \u0026quot;\\x6f\\x72\\x6c\\x64\\x21\\x0a\u0026quot;; int main(int argc, char **argv) { (*(void(*)())code)(); return 0; } ","date":"2022-05-02","permalink":"https://saligrama.io/blog/post/hello/","tags":[],"title":"Hello, world!"}]